; helloos.asm (Day 3 版本)
; TAB=4

; ---------------------------------
; 启动扇区 (Boot Sector)
; ---------------------------------

BITS 16     ; 告诉 NASM 我们在 16 位实模式
ORG  0x7c00 ; 关键！告诉 NASM 我们的程序会被加载到 0x7c00，所有地址都从这里开始计算

; ---------------------------------
; FAT12 软盘头部 (BPB)
; ---------------------------------
    ; 这部分和 Day 2 完全一样
    JMP entry     ; (3字节) EB 4e 90 -> 跳转到 entry 标签
    ; 作者在 JMP 后面省略了 DB 0x90 (NOP)，但 NASM 会自动帮我们对齐
    ; 我们还是把它写上，和书里保持一致
    DB 0x90

    ; FAT12 "名片" (元数据)
    DB "HELLOIPL" ; 厂商名 (8 字节)
    DB 0x00, 0x02, 0x01, 0x01, 0x00
    DB 0x02, 0xe0, 0x00, 0x40, 0x0b, 0xf0, 0x09, 0x00
    DB 0x12, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00
    DB 0x40, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x29, 0xff
    DB 0xff, 0xff, 0xff, "HELLO-OS   " ; 卷标 (11 字节)
    DB "FAT12   " ; 文件系统类型 (8 字节)
    DB 0x00, 0x00

    RESB 16     ; 保留 16 字节

; ---------------------------------
; 程序核心 (Day 3 新内容)
; ---------------------------------
entry:
    MOV AX, 0     ; AX 寄存器清零
    MOV SS, AX    ; 设置 栈段寄存器 (SS)
    MOV SP, 0x7c00; 设置 栈顶指针 (SP)。栈从 0x7c00 向下增长
    MOV DS, AX    ; 设置 数据段寄存器 (DS)
    MOV ES, AX    ; 设置 额外段寄存器 (ES)

    ; ------ 打印 "hello, world" ------
    MOV SI, msg   ; 把 msg 标签的地址 (0x7c00 + ...) 放到 SI 寄存器

putloop:
    MOV AL, [SI]  ; 从 [SI] 指向的内存地址取 1 个字节，放入 AL
    ADD SI, 1     ; SI 寄存器 +1，指向下一个字符
    CMP AL, 0     ; 比较 AL 寄存器里的值是不是 0
    JE  fin       ; JE = Jump if Equal。如果 AL 等于 0，就跳转到 fin 标签

    ; (如果 AL 不是 0，就执行打印)
    MOV AH, 0x0e  ; AH=0x0e 是 BIOS 10h 中断的 "显示一个字符" 功能号
    MOV BX, 15    ; BX=15 (0x0f) 是颜色：亮白色
    INT 0x10      ; 调用 BIOS 10h (显卡) 中断服务

    JMP putloop   ; 无条件跳回 putloop 标签，处理下一个字符

fin:
    HLT           ; HLT = Halt，让 CPU 停止工作，节能
    JMP fin       ; 无限循环这个 HLT 指令，防止 CPU "跑飞"

; ------ 数据区 (Data) ------
msg:
    DB 0x0a, 0x0a ; 换行 (0x0a) 两次
    DB "hello, world"
    DB 0x0a       ; 换行
    DB 0          ; 字符串结束标志 (C 语言的 \0)

; ---------------------------------
; 填充 & 魔法数字
; ---------------------------------
    ; 我们的代码 + BPB + JMP + NOP + resb 16 一共是 142 字节
    ; (JMP 3 + NOP 1 + BPB 59 + RESB 16 + code 54 + data 16)
    ; 不对，我还是用 NASM 的方法来算：
    ; $ = 当前地址
    ; $$ = ORG 地址 (0x7c00)
    ; ($ - $$) = 从 0x7c00 开始，我们已经写了多少字节
    ; 510 - ($ - $$) = 还需要多少字节才能到第 510 字节
    
    RESB 510 - ($ - $$)   ; ($ - $$) 是 NASM 提供的"当前地址"，自动计算填充！
                          ; 这比我们手算 370 靠谱多了！

    DB 0x55, 0xaa       ; 启动扇区魔法数字 (第 511, 512 字节)

; ---------------------------------
; 启动扇区 (512 字节) 结束
; ---------------------------------

; FAT 表1 (和 Day 2 一样)
DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
RESB 4600

; FAT 表2 (和 Day 2 一样)
DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
RESB 1469432

